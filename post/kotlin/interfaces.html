---
layout: default
---

<article>
  <nav class="toc">
    <div>دسترسی سریع</div>
    <ul class="list-group">
      <li>
        <a href="#p0">توضیحات و ویژگی ها</a>
      </li>
      <li>
        <a href="#p1">استفاده از اینترفیس</a>
      </li>
      <li>
        <a href="#p2">اینترفیس های تابعی</a>
      </li>
      <li>
        <a href="#p3">خلاصه</a>
      </li>
    </ul>
  </nav>

  <section id="p0">
    <h2>توضیحات و ویژگی ها</h2>

    <p>
      در این مطلب به مقایسه و بررسی اینترفیس (interface) ها با کلاس های ابستراکت
      و ویژگی آنها در کاتلین پرداختیم و همچنین اینترفیس های تابعی در کاتلین رو
      بررسی کردیم.
    </p>

    <p>
      مشابه کلاس های ابستراکت در اینترفیس (interface) ها، میتونیم توابع concrete
      (کامل) و توابع abstract تعریف کنیم.
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
interface Foo {

 //Concrete Function Implementation
 fun myConcreteFunction(){
  println("From Concrete Function")
 }

 //Abstract Function
 fun myAbstractFunction()

}
                  </pre
        >
      </div>
    </div>

    <p>
      در اینترفیس ها نمیتونیم کانستراکتور تعریف کنیم؛ چون اینترفیس ها
      کانستراکتور ندارن پس پراپرتی ها باید abstract باشن مگه پراپرتی های val که
      تابع getter دارن.
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
interface Foo {

  abstract var prop0: String

  val prop1: String get() = "Prop1"

}
                  </pre
        >
      </div>
    </div>

    <p>هر اینترفیس میتونه از یک یا چند اینترفیس ارث بری کنه.</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
interface A {
  ... 
}

interface B {
  ...
}

interface C: A, B {
  ...
}
                  </pre
        >
      </div>
    </div>

    <p>
      همانند کلاس های ابستراکت از اینترفیس ها نیز نمیشه نمونه (شی) سازی کرد.
    </p>

    <p>
      هر کلاسی میتونه از یک کلاس و<strong>چند اینترفیس</strong> ارث بری کنه.
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
interface A {
  ...
}

interface B {
  ...
}
            
open class Foo {
  ...
}


class Bar: Foo(), A, B{
  ...
}
                  </pre
        >
      </div>
    </div>
  </section>

  <section id="p1">
    <h2>استفاده از اینترفیس</h2>

    <p>به دو روش میتونیم از اینترفیس استفاده کنیم:</p>

    <section>
      <h3>۱- ارث بری از اینترفیس</h3>
      <p>
        در این روش مانند قسمت قبل که اشاره شد اینترفیس رو تعریف میکنیم و ازش
        توسط کلاس یا اینترفیس دیگه ارث بری میکنیم.
      </p>
    </section>

    <section>
      <h3>۲- پیاده سازی مستقیم اینترفیس</h3>

      <p>میتونیم اینترفیس رو مانند زیر در کد پیاده‌سازی کنیم:</p>

      <div class="sample">
        <div class="snippet-container">
          <pre class="snippet Kotlin">
interface Player{
  fun play()

  fun stop()

  fun pause()

}


fun main(){

val player = object: Player{

  override fun play(){
    ...
  }

  override fun stop(){
    ...
  }

  override fun pause(){
    ...
  }
  
}

}
                  </pre
          >
        </div>
      </div>
    </section>
  </section>

  <section id="p2">
    <h2>اینترفیس های تابعی</h2>

    <p>
      اینترفیس هایی که فقط یک تابع دارن میتونیم به صورت تابعی داخل کد پیاده
      سازیشون کنیم به این اینترفیس ها Single Abstract Method Interface (SAM) نیز
      گفته میشه.
    </p>

    <p>
      برای اینکه یک اینترفیس تابعی باشه باید قبل از کلیدواژه ی اینترفیس از کلید
      واژه ی fun نیز استفاده کنیم.
    </p>

    <p>در مثال زیر اینترفیس رو به دو روش معمولی و تابعی پیاده‌سازی کردیم:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
fun interface PredictableNumber{
  fun predict(v: Int): Boolean
}


fun main(){
  // پیاده سازی به روش معمولی
  val prime = object: PredictableNumber{
    override fun predict(v: Int){
      var isPrime = false
      for(i in 0 until v/2){
        if(v % i == 0){
          isPrime = true
          break
        }
      }
      return isPrime
    }
  }

  //پیاده سازی به روش تابعی
  val even = PredictableNumber{ it % 2 == 0}

  println("is 53 prime? ${prime.predict(53)"}

  println("is 53 even? ${even.predict(53)"}
                  </pre
        >
      </div>
    </div>
  </section>

  <section id="p3">
    <h2>خلاصه</h2>

    <li>
      در اینترفیس ها در کاتلین مانند کلاس های ابستراکت هم تابع ابستراکت میتونیم
      تعریف کنیم هم تابع کامل.
    </li>
    <li>در اینترفیس ها نمیتونیم کانستراکتور داشته باشیم.</li>
    <li>
      در اینترفیس ها نمیتونیم پراپرتی تعریف کنیم مگه پراپرتی نوع val با تابع
      getter باشه.
    </li>

    <li>هر اینترفیس میتونه از یک یا چند اینترفیس ارث ببره.</li>

    <li>هر کلاسی علاوه بر یک کلاس از یک یا چند اینترفیس میتونه ارث ببره.</li>

    <li>علاوه بر ارث بری میتونیم اینترفیس ها رو داخل کد پیاده‌سازی کنیم.</li>

    <li>
      اینترفیس هایی که فقط یک تابع ابستراکت دارند رو میتونیم به صورت تابعی
      پیاده‌سازی کنیم که بهشون اینترفیس های تابعی و یا Single Abstract Method
      Interface (SAM) گفته میشه.
    </li>
  </section>
</article>

{% capture links %}
<li>
  <a href="/post/kotlin/abstract-classes.html">کلاس های ابستراکت</a>
</li>

<li>
  <a href="/post/kotlin/inheritance.html">وراثت</a>
</li>

<li>
  <a href="/post/kotlin/objects-and-classes.html">آبجکت و کلاس ها</a>
</li>

<li>
  <a href="/post/kotlin/nested-classes.html">کلاس های تو در تو</a>
</li>

<li>
  <a href="https://kotlinlang.org/docs/interfaces.html"
    >مطالعه در وبسایت رسمی کاتلین</a
  >
</li>
{% endcapture %} {% include article-foot.html relative_links = links %}

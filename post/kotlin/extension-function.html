---
layout: default
---

<article>
  <nav class="toc">
    <div>دسترسی سریع</div>
    <ul>
      <li>
        <a href="#p0">تعریف Extension در کاتلین</a>
      </li>
      <li>
        <a href="#p1">تابع اکستنشن</a>
      </li>
      <li>
        <a href="#p2">اکستنشن پراپرتی در کاتلین</a>
      </li>
      <li>
        <a href="#p3">اکستنشن های Companion Object</a>
      </li>
      <li>
        <a href="#p4">تعریف اکستنشن به عنوان عضو یک کلاس</a>
      </li>
      <li>
        <a href="#p5">خلاصه</a>
      </li>
    </ul>
  </nav>

  <section id="p0">
    <h2>تعریف Extension در کاتلین</h2>

    <blockquote>
      در این مطلب فرض شده با شی گرایی و توابع (متدها) در کاتلین آشنایی دارید.
      اگه با توابع در کاتلین اشنایی ندارید میتونید به مطلب
      <a class="text-decoration-none" href="/post/kotlin/functions.html"
        >بررسی توابع در کاتلین</a
      >
      مراجعه کنید.
    </blockquote>

    <p>
      اکستنشن ها در کاتلین توابع و متغیر هایی هستن که برای کلاس تعریفشون میکنیم.
    </p>

    <p>
      اکستنشن ها تغییری در داخل کلاس ایجاد نمیکنن و مانند پراپرتی (field) و تابع
      (function) های عضو کلاس اونا رو صدا میزنیم.
    </p>

    <p>
      با اینکه اکستنشن ها مانند اعضای کلاس صدا زده میشن اما عضوی به کلاس اضافه
      نمیکنن و
      <a class="text-decoration-none" href="/post/java/static-keyword.html"
        >استاتیک</a
      >
      در نظر گرفته میشن. مثلا اگه برای دو کلاس تابع اکستنشن یکسان تعریف کرده
      باشیم، و دو کلاس از همدیگ ارث ببرن بدون توجه به وراثت؛ زمان کامپایل مشخص
      میشه تابع اکستنشن کدوم کلاس اجرا میشه.
    </p>

    <p>
      معمولا اکستنشن ها رو داخل فایل کاتلین؛ یعنی به صورت
      <a
        class="text-decoration-none"
        href="https://kodedevel.github.io/post/kotlin/functions.html#p8"
        >Top Level</a
      >
      تعریف میکنیم.
    </p>

    <p>
      اکستنشن ها شامل توابع اکستنشن، اکستنشن پراپرتی (Extension Property)، و
      اکستنشن های Companion Object هستند.
    </p>
  </section>

  <section id="p1">
    <h2>تابع اکستنشن</h2>

    <p>به توابعی گفته میشه که برای یک کلاس، در خارج از کلاس تعریف میکنیم.</p>

    <p>فرم کلی:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
fun &lt;T&gt; MyClass&lt;T&gt;.myFunction(...){

    ....

}
                    </pre
        >
      </div>
    </div>

    <p>
      در اینجا MyClass اسم کلاس مورد نظر است یه نقطه میزاریم سپس اسم دلخواه برای
      تابعمون مینویسیم و مثل توابع معمولی پارامتر های دلخواه داخل پرانتز تابع رو
      تعریف میکنیم.
    </p>
    `

    <p>
      همینطور اگه برای کلاس Generic تعریف شده بود مانند بالا میتونیم برای تابعی
      که تعریف میکنیم Generic تعریف کنیم تا برای هر نوع متغیری قابل استفاده باشه
    </p>

    <p>توابع اکستنشن رو مثل توابع عضو کلاس (ممبر فانکشن ها) صدا میزنیم.</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
val myClass = MyClass&lt;T&gt;()
myClass.myFunction(...)
                    </pre
        >
      </div>
    </div>

    <div class="note">
      <p class="h6">نکته:</p>
      <p>
        اگه تابع اکستنشن با یکی از توابع داخل کلاس از نظر پارامتر و اسم یکی باشه
        هنگام صدا زدن، تابع داخل کلاس به اجرا در میاد.
      </p>
    </div>

    <p>مثال:</p>
    <p>
      یک function به کلاس String اضافه کردیم که بررسی میکنه یک String متقارن است
      یا خیر
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
fun String.isPalindrome(): Boolean{
   return if (length &lt;= 1) true
    else if (this[0] != this[length -1]) false
    else pstring(1, length -1).isPalindrome()
}

fun main(){
  val s0 = "moon"
  val s1 = "noon"
  val s2 = "abf"
  val s3 = "aba"

  println("is $s0 palindrome? ${s0.isPalindrome()}")
  println("is $s1 palindrome? ${s1.isPalindrome()}")
  println("is $s2 palindrome? ${s2.isPalindrome()}")
  println("is $s3 palindrome? ${s3.isPalindrome()}")
}
                    </pre
        >
      </div>
    </div>

    <p>مثال:</p>
    <p>اجرای تابع اکستنشن از دو کلاس پدر و فرزند.</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
open class A { }

class ChildA: A() { }

fun A.printInfo(){
  println("An Extension for A")
}

fun ChildA.printInfo(){
  println("An Extension for ChildA")
}

fun show(a: A){
  a.printInfo()
}

fun main(){
  show(A())
  show(ChildA())
}
                    </pre
        >
      </div>
    </div>
    <p>
      همینطور که در ابتدا گفتیم اکستنشن ها استاتیک در نظر گرفته میشن و زمان
      کامپایل مشخص میشه تابع کدوم کلاس اجرا بشه در بالا نتیجه اجرای تابع
      printInfo مربوط به A است. چون پارامتر show از نوع A است.
    </p>

    <h3>استفاده از کلیدواژه ی this داخل تابع:</h3>

    <p>
      داخل تابع اکستنشن با کلید واژه ی this میتونیم به نمونه کلاس و اعضای کلاس
      دسترسی داشته باشیم.
    </p>

    <p>مثال:</p>

    <p>تابع swap رو برای MutableList هایی از نوع Int تعریف میکنیم.</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}
                    </pre
        >
      </div>
    </div>

    <p>این تابع برای هر MutableList که نوعش Int باشه قابل استفاده است.</p>

    <p>صدا زدن تابع:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
val list = mutableListOf(96, 78, 44)
list.swap(0, 2)
                    </pre
        >
      </div>
    </div>

    <h3>تعریف تابع اکستنشن به صورت Generic:</h3>

    <p>میتونیم توابع اکستنشن رو به صورت، جنریک تعریف کنیم.</p>

    <p>مثال:</p>

    <p>
      در زیر تابع swap رو به صورت جنریک تعریف کردیم تا برای هر نوعی قابل استفاده
      باشه.
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
// &lt;T&gt; after function satisfies the generic.

fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}
                    </pre
        >
      </div>
    </div>
  </section>

  <section id="p2">
    <h2>اکستنشن پراپرتی در کاتلین</h2>

    <p>فرم کلی:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
val &lt;T&gt; MyClass&lt;T&gt;.myProperty: Int
    get(){...}
                    </pre
        >
      </div>
    </div>

    <p>کاملا شبیه extension function هاست</p>
    <p>اکستنشن پروپرتی ها نمیتونن دارای مقدار اولیه باشن.</p>

    <p>
      همونطور که گفتیم extension ها ربطی به کلاس ندارن پس مقدار اولیه ای برای
      extension property ها وجود نداره
    </p>

    <p>مثال:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
val Int.even: Boolean get(){
    return this % 2 == 0
}

fun main(){
  val num0 = 24
  val num1 = 7

  println("is $num0 even? ${num0.even}")
  println("is $num1 even? ${num1.even}")
}
                    </pre
        >
      </div>
    </div>

    <p>
      در بالا یک property به کلاس Int اضافه کردیم که بررسی میکنه عدد زوجه یا نه.
    </p>
  </section>

  <section id="p3">
    <h2>اکستنشن های Companion Object</h2>

    <p>
      اگه برای یک کلاس Companion Object تعریف شده باشه، میتونیم برای Companion
      Object اکستنشن فانکشن و اکستنشن پراپرتی تعریف کنیم.
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
MyClass.Companion.myFunction(){

//...

}
                    </pre
        >
      </div>
    </div>

    <p>برای صدا زدنش مثل بقیه اعضای داخل companion object عمل میکنیم:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
MyClass.myFunction()
                    </pre
        >
      </div>
    </div>
  </section>

  <section id="p4">
    <h2>تعریف اکستنشن به عنوان عضو یک کلاس</h2>

    <div class="note">
      <p class="note-head">توجه:</p>
      <p>
        برای مطالعه ی این بخش توصیه میشه با مبانی شی گرایی اشنایی داشته باشید.
      </p>
    </div>

    <p>
      میتونیم برای یک کلاس داخل کلاس دیگه اکستنشن تعریف کنیم به کلاسی که داخلش
      اکستنشن تعریف کردیم dispatch receiver و به کلاسی که اکستنشن رو براش تعریف
      کردیم extension receiver میگیم.
    </p>
    <p>مثال:</p>

    <p>استفاده از یک کلاس به عنوان extension receiver.</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
class MyExtensionReceiver{               
  val id: Int = (0..100).random()

  fun printMessage(){
    println("This is a message from MyExtensionReceiver")
  }
}
                      </pre
        >
      </div>
    </div>

    <p>استفاده از یک کلاس به عنوان dispatch receiver.</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
class MyDispatchReceiver(val er: MyExtensionReceiver){

  MyExtensionReceiver.printInfo(){
    println("The id of MyExtensionReceiver is $id")
  }

}
                      </pre
        >
      </div>
    </div>

    <div class="note">
      <p class="note-head">توجه:</p>
      <p>
        اگه بخوایم داخل تابع printInfo یکی از اعضای dispatch receiver رو صدا
        بزنیم و با عضو extension receiver هم نام باشه، اولویت با اعضای extension
        receiver است. برای همین موقع صدا زدن اعضای dispatch receiver از
        <strong>this@ClassName</strong> استفاده میکنیم تا از تداخل اسمی جلوگیری
        بشه.
      </p>
    </div>

    <p>
      فرض کنید در کلاس MyDispatchReceiver عضوی با اسم id نیز وجود داشته باشه:
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
class MyDispatchReceiver(val er: MyExtensionReceiver){
  val id: Int = (0..20).random()

  MyExtensionReceiver.printInfo(){
    val extensionId = id
    println("The id of MyExtensionReceiver is $id")
    val dispatchId = this@MyDispatchReceiver.id
    println("The id of MyDispatchReceiver is $dispatchId")

  }

}
                      </pre
        >
      </div>
    </div>

    <p>
      میتونیم تابع اکستنشن داخل کلاس رو به صورت open تعریف کنیم تا در وراثت
      بتونیم override کنیم.
    </p>

    <div class="note">
      <p class="note-head">توجه:</p>
      تابع اکستنشن برای extension receiver و فرزندانش استاتیک و برای dispatcher
      receiver عضو به حساب میاد.
    </div>

    <p>مثال:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
open class A { }

class ChildA: A() { }

open class B {

  open fun A.printInfo(){
    println("An Extension function for A in B")
  }

  open fun ChildA.printInfo(){
    println("An Extension function for ChildA in B")
  }

  fun call(a: A){
    a.printInfo()
  }

}

class ChildB: B(){

  @override
  fun A.printInfo("An Extension function for A in ChildB") 

  @override
  fun ChildA.printInfo("An Extension function for ChildA in ChildB")

}

fun main() {
    
    val b = B()
    b.call(A())
    b.call(ChildA())

    val cb = ChildB()

    cb.call(A())
    cb.call(ChildA())
}
                      </pre
        >
      </div>
    </div>

    <p>
      ابتدا برای کلاس های A و ChildA تابع اکستنشن printInfo رو در B تعریف کردیم،
      سپس با ارث بری ChildB از B این دو تابع رو در ChildB بازنویسی کردیم، سپس در
      تابع main، تابع call رو صدا کردیم و نمونه جدید از A و ChildA رو به call
      پاس دادیم. چون پارامتر تعریف شده در call از نوع A است، تابع printInfo برای
      A در B و ChildB اجرا میشه.
    </p>
  </section>

  <section id="p5">
    <h2>خلاصه</h2>

    <p>
      -در کاتلین Extension ها تاثیری روی کلاس ندارن وقتی برای یک کلاس extension
      تعریف میکنیم فقط بیان میکنیم که function یا property تعریف شده رو باید با
      استفاده از متغیر کلاس صدا بزنیم.
    </p>

    <p>
      -برای صدا زدن extension ها مانند اعضای داخل کلاس باید اسم متغیر کلاس نقطه
      و اسم function یا property تعریف شده رو بنویسیم.
    </p>

    <p>در قطعه کد زیر به طور خلاصه از هر سه نوع یک نمونه بیان شده است:</p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Koitlin">
//Extension Function
fun MyClass.myExtensionFunction(){
    //...
}

//Extension Property
val MyClass.myExtensionProperty: List&lt;String&gt; get(){
    //...
}

//Companion object extension
fun MyClass.Companion.myExtensionCompanionFunction(){
    //...
}

val myObject = MyClass()

myObject.myExtensionFunction()

val list = myObject.myExtensionProperty

MyClass.myExtensionCompanionFunction()
            </pre
        >
      </div>
    </div>
  </section>

  <p>
    در این مطلب به بررسی اکستنشن ها در کاتلین پرداختیم و با توابع اکستنشن ،
    اکستنشن پراپرتی و اکستنشن های companion object اشنا شدیم و اکستنشن های عضو
    کلاس رو بررسی کردیم.
  </p>

  <p>موفق باشید</p>
</article>
{% capture relative_links %}
<li>
  <a href="/post/kotlin/functions.html">بررسی توابع در کاتلین</a>
</li>
<li>
  <a href="/post/kotlin/anonymous-function-and-lambda.html"
    >توابع بی نام و عبارات لامبدا در کاتلین</a
  >
</li>
<li>
  <a href="/post/kotlin/higher-order-functions.html"
    >توابع مرتبه ی بالا در کاتلین</a
  >
</li>
<li>
  <a href="https://kotlinlang.org/docs/extensions.html"
    >سایت رسمی کاتلین برای مطالعه موضوع</a
  >
</li>
{% endcapture %} {% include article-foot.html relative_links = relative_links %}

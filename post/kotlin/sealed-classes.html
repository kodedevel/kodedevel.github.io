---
layout: default
---

<article>
  <nav class="toc">
    <div>دسترسی سریع</div>
    <ul>
      <li>
        <a href="#p0">توضیحات</a>
      </li>
      <li>
        <a href="#p1">بررسی کاربرد ها و ویژگی ها</a>
      </li>
      <li>
        <a href="#p2">خلاصه</a>
      </li>
    </ul>
  </nav>

  <section id="p0">
    <h2>توضیحات</h2>

    <p>
      کلاس های sealed در کاتلین به منظور جلوگیری از ارث بری در خارج از پکیج یا
      ماژول طراحی شدن؛ کلمه ی sealed به معنی مهر و موم شده است.
    </p>
    <p>
      به عبارت دیگه هیچ
      <a class="text-decoration-none" href="inheritance.html">subclass</a>
      مستقیمی برای این کلاس ها در خارج از پکیج یا ماژول قابل تعریف نیست.
    </p>

    <p>
      ابتدای این کلاس ها کلیدواژه ی <strong>sealed</strong> میزاریم و بقیشو مثل
      کلاس معمولی تعریف می کنیم:
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
sealed class MyClass {
    ...
}
                        </pre
        >
      </div>
    </div>
  </section>

  <section id="p1">
    <h2>بررسی کاربرد ها و ویژگی ها</h2>

    <p>
      همینطور که گفتیم sealed دسترسی به کلاس رو محدود به یک پکیج در برنامه می
      کنه. با این کار علاوه بر اینکه کد های برنامه منظم و خواناتر میشه فرض کنید
      میخوایم یک api عمومی از برنامه بدیم بیرون کلاس هایی که با sealed تعریف می
      کنیم به طور مستقیم برای توسعه دهنده قابل دسترسی نیستند.
    </p>

    <p>
      کلاس های sealed
      <a class="text-decoration-none" href="abstract-classes.html">ابستراکت</a>
      هستند بنابراین به طور مستقیم نمیتونیم ازشون آبجکت ایجاد کنیم.
    </p>
    <p>
      باید
      <a class="text-decoration-none" href="access-modifiers.html"
        >سطح دسترسی</a
      >
      <a class="text-decoration-none" href="objects-and-classes.html"
        >کانستراکتور</a
      >
      های کلاس سیلد protected یا private باشه.
    </p>

    <p>
      فرض کنید حیوون خونگی داریم و میخوایم بهشون غذا بدیم اما نمیخوایم این غذا
      رو به حیوونای دیگه این غذا رو بدیم بنابراین برای غذا کلاس sealed تعریف می
      کنیم:
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
fun main() {

    val myCat = PetFood.MyCat()
    val myDog = PetFood.MyDog()

    myCat.feeding()
    myDog.feeding()
}

sealed class PetFood private constructor(){
    abstract fun feeding()

    class MyCat : PetFood() {
        override fun feeding() {
            println("I'm Feeding my cat!")
        }
    }

    class MyDog: PetFood(){
        override fun feeding() {
            println("I'm feeding my dog!")
        }
    }
}
                        </pre
        >
      </div>
    </div>

    <p>
      در بالا سطح دسترسی کانستراکتور کلاس PetFood به صورت private تعریف شده
      بنابراین فقط کلاس های تودرتو میتونن از کلاس PetFood ارث بری داشته باشن که
      در مورد فوق دو کلاس MyDog و MyCat رو به صورت تو در تو تعریف کردیم.
    </p>

    <p>
      یکی از ویژگی کلاس های sealed کاربرد اونا در عبارت when است به این صورت
      وقتی که ساب کلاس هاشونو در when بررسی می کنیم در آخر عبارت نیاز به استفاده
      از else نداریم.
    </p>

    <div class="sample">
      <div class="snippet-container">
        <pre class="snippet Kotlin">
fun main(){
    val myCat = PetFood.MyCat()
    val myDog = PetFood.MyDog()

    printHungryPetVoice(myCat)
    myCat.feeding()

    printHungryPetVoice(myDog)
    myDog.feeding()
}

fun printHungryPetVoice(petFood: PetFood){
    when(petFood){
        is PetFood.MyCat -&gt; println("Meow")
        is PetFood.MyDog -&gt; println("Barking")
    }
}
                        </pre
        >
      </div>
    </div>
  </section>

  <section id="p2">
    <h2>خلاصه</h2>
    <ul>
      <li>
        کلاس های sealed در خارج از پکیج به طور مستقیم برای ارث بری در دسترس
        نیستند.
      </li>
      <li>کلاس های sealed در کاتلین ابسترکت هستند</li>
      <li>
        سطح دسترسی کانستراکتور های این کلاس ها یا protected باید باشه یا
        private.
      </li>
      <li>
        ساب کلاس های این کلاس ها کاملا با عبارت when برای بررسی سازگاری دارن و
        نیاز به else اخر شرط نداریم.
      </li>
    </ul>
  </section>
</article>

{% capture links %}
<li>
  <a href="/post/kotlin/objects-and-classes.html">آبجکت و کلاس ها</a>
</li>

<li>
  <a href="/post/kotlin/inheritance.html">وراثت</a>
</li>

<li>
  <a href="/post/kotlin/abstract-classes.html">کلاس های ابسترکت</a>
</li>

<li>
  <a href="https://kotlinlang.org/docs/sealed-classes.html"
    >مطالعه در وبسایت رسمی کاتلین</a
  >
</li>
{% endcapture %} {% include article-foot.html relative_links = links %}
